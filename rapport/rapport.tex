\documentclass[a4paper, titlepage, oneside, 12pt]{article}%      autres choix : book  report

\usepackage[utf8]{inputenc}%           gestion des accents (source)

\usepackage[T1]{fontenc}%              gestion des accents (PDF)

\usepackage[francais]{babel}%          gestion du français

\usepackage{textcomp}%                 caractères additionnels

\usepackage{mathtools,  amssymb, amsthm}% packages de l'AMS + mathtools

\usepackage{lmodern}%                  police de caractère

\usepackage{geometry}%                 gestion des marges

\usepackage{graphicx}%                 gestion des images

\usepackage{xcolor}%                   gestion des couleurs

\usepackage{array}%                    gestion améliorée des tableaux

\usepackage{calc}%                     syntaxe naturelle pour les calculs

\usepackage{titlesec}%                 pour les sections

\usepackage{titletoc}%                 pour la table des matières

\usepackage{fancyhdr}%                 pour les en-têtes

\usepackage{titling}%                  pour le titre

\usepackage[framemethod=TikZ]{mdframed}% print frames

\usepackage{caption}%                  for captionof

\usepackage{listings}

\usepackage{enumitem}%                 pour les listes numérotées

\usepackage{microtype}%                améliorations typographiques

\usepackage{csvsimple}%                 convertir un fichier .csv en tableau

\usepackage{hyperref}%                 gestion des hyperliens

\usepackage[french]{algorithm2e}
\hypersetup{pdfstartview=XYZ}%         zoom par défaut

%%%%%%%%%%%%%%%%%%%%%% CONFIGURATION %%%%%%%%%%%%%%%%%%%%%%%%%%

\mdfdefinestyle{MyFrame}{%
    linecolor=black,
    outerlinewidth=0pt,
    roundcorner=10pt,
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    innerrightmargin=20pt,
    innerleftmargin=20pt,
    backgroundcolor=black!10!white}

\captionsetup[lstlisting]{labelformat=empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{prop}{Proposition}

\hypersetup{                    % parametrage des hyperliens
    colorlinks=true,                % colorise les liens
    breaklinks=true,                % permet les retours à la ligne pour les liens trop longs
    urlcolor= red,                 % couleur des hyperliens
    linkcolor= blue,                % couleur des liens internes aux documents (index, figures, tableaux, equations,...)
    citecolor= green                % couleur des liens vers les references bibliographiques
    }
%%%%%%%%%%%%%%%%%%%%%% COMMANDES PL %%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\boldmin{\mathop{\mathbf{min}}}
\newcommand\boldmax{\mathop{\mathbf{max}}}



% I don't know how it works but it does !
\def\foo#1#2{%
\newenvironment{variables}
{\paragraph{Variables :}
#1{2}}
{#2}}
\expandafter\foo
  \csname alignat*\expandafter\endcsname
  \csname endalignat*\endcsname


% \newenvironment{variables}
% {  \paragraph{Variables :}
  
%   \alignat{2} }
% {  \endalignat }

\newenvironment{fonctionobj}
{ \paragraph{Fonction objectif :}


  }
{  }

\def\cons#1#2{%
\newenvironment{contraintes}
{\paragraph{Contraintes :}
#1{2}}
{#2}}
\expandafter\cons
  \csname alignat*\expandafter\endcsname
  \csname endalignat*\endcsname


\newcommand{\variable}[4]{\underbrace{#1}_{\mathclap{\text{#4}}} \in #2 &\ #3 \\}
\newcommand{\fobj}[2]{\begin{alignat*}{2} #1 &\qquad \text{\footnotesize (#2)} \end{alignat*}}
\newcommand{\constraint}[3]{#1 &,\ & #2 & 
\if\relax\detokenize{#3}\relax
\\
\else
\qquad \text{\footnotesize \textcolor{blue}{\textit{#3}}} \\ 
\fi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\title{Rapport pour le projet de MOGPL}
\date{\today}
\author{Pierre Mahé \& François Thiré}

 % Modèle pour écrire un programme linéaire
 % \begin{alignat*}{2}
 %    \text{minimize }   & \sum_{i=1}^m c_i x_i + \sum_{j=1}^n d_j t_j\  \\
 %    \text{subject to } & \sum_{i=1}^m a_{ij} + e_j t_j \geq g_j &,\ & 1\leq j\leq n\\
 %                       & f_i x_i + \sum_{j=1}^n b_{ij}t_j \geq h_i\ &,\ & 1\leq i\leq m\\
 %                       & x\geq 0,\ t_j\geq 0\ &,\ & 1\leq j\leq n,\ 1\leq i\leq m
 %  \end{alignat*}


\begin{document}

\maketitle
{
  \hypersetup{linkcolor=black}
  \tableofcontents
}

\newpage

\section{Première modélisation du problème}
\subsection{Question 1}
La définition du programme $\mathcal{P}_0$ est donné dans l'encadré ci-dessous :
\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{x_{i,j}}{\mathbb{B}}{1 \leq i,j \leq n}{Vaut $1$ si l'agent $a_i$ reçoit le bien $b_j$}
\end{variables}

\begin{fonctionobj}

\fobj{\boldmax \ \frac{1}{n}\ \sum_{\substack{1\leq i,j \leq n}} u_{i,j}x_{i,j}}
{avec $u_{i,j}$ les coefficients d'utilités du bien $i$ pour l'agent $j$}
\end{fonctionobj}

\begin{contraintes}
   \constraint{\sum_{i=1}^n x_{i,j} =1}{ 1\leq j\leq n}{$1$ agent par bien}
   \constraint{\sum_{j=1}^n x_{i,j} =1}{ 1\leq i\leq n}{$1$ bien par agent}
\end{contraintes}

\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{P}_0$}

\subsection{Question 2}
Vous trouverez le code \textit{Python} du modèle $\mathcal{P}_0$  dans le répertoire \textit{Python/modelisation\_P0}. 
L'implémentation du modèle et la génération des tests se fait dans le fichier \textbf{P0.py}. Pour connaître les options possibles du programme, veuillez lancer la commande

%TO DO : faire un meilleur rendu
\begin{lstlisting}[language=bash]
gurobi.sh P0.py -h
\end{lstlisting}

En particulier pour lancer le programme avec comme taille $n=100$ et $M=1000$ on utilisera la commande suivante :
\begin{lstlisting}[language=bash]
gurobi.sh P0.py -n 100 -M 1000
\end{lstlisting}

Si vous choisissez d'utiliser les options pour enregistrer le modèle et écrire la solution dans un fichier, alors le programme va créer respectivement deux sous-dossiers\footnote{à partir du dossier courant} \textit{modele} et \textit{solutions} qui contiendra ces fichiers. Ces remarques s'appliquent aussi bien pour les autres implémentations demandées par le projet.

\subsection{Question 3}

Nous avons automatisé la création des tableaux par un script \textit{bash} que vous trouverez dans le répertoire \textit{Python/stats/question\_3}. Ce programme va générer des fichiers \textit{csv} qui pourront ensuite être importés dans un fichier \LaTeX en utilisant le package \textit{csvsimple}. Voici donc les résultats trouvés :

\begin{table}[h]
\begin{center}
\csvautotabular{csv/question_3/data_10.csv}
\caption{Résultats lorsque $M=10$}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\csvautotabular{csv/question_3/data_100.csv}
\caption{Résultats lorsque $M=100$}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\csvautotabular{csv/question_3/data_1000.csv}
\caption{Résultats lorsque $M=1000$}
\end{center}
\end{table}
\section{Approche égalitariste}
\subsection{Question 4}

Avant de parler de la construction du graphe, nous mentionnons que cette question nous a posé quelques problèmes. En effet, le sujet ne spécifiait pas une version de python a utiliser. Le projet à donc été implémenté en utilisant la version \textbf{3.4} de Python. Seulement, il se trouve que \textit{gurobi} n'est pas compatible avec cette version. D'un autre côté, la librairie \textbf{pygraph} étant compatible avec python \textbf{3.4}, elle posait problème si on voulait utiliser \textit{gurobi}. Une première solution à donc été d'utiliser la librairie \textit{graph\_tools}. L'implémentation se trouve dans \textit{Python/modelisation\_graph/graph\_tools.py}. Cependant l'implémentation souffre de deux problèmes :
\begin{itemize}
\item Les capacités utilisent directement les coefficients~;
\item L'algorithme est pas au point, en particulier il n'utilise pas une recherche dichotomique~;
\end{itemize}

L'implémentation qui nous intéresse se situe à l'adresse \textit{Python/modelisation\_graph/approche\_egalitariste.py}\footnote{Vous pouvez utiliser l'option -h pour savoir quelles options utiliser}. Dans la suite nous allons donc décrire le graphe, décrire l'algorithme et donner une justification succinte de la correction de l'algorithme.

\subsubsection{Description du graphe : } 

Soit $n$ le nombre d'agents ainsi que le nombre de biens à répartir. Soit $u_{i,j}$ l'utilité du bien $j$ pour l'agent $i$. 
On fait l'hypothèse que les coefficient de la mtrice $u_{i,j}$ soient distincts\footnote{L'hypothèse n'est pas très forte car il suffit sinon de tirer au hasard un $\varepsilon>0$ pour différencier les coefficients égaux}. 
On construit le graphe orienté suivant :
$G=(V,E)$ où 
\begin{itemize}
\item $V=\{s,a_0,a_1,\dots, u_{n-1}, o_0,o_1,\dots, o_{n-1},t\}$
\item $\forall i,j \in \{1,\dots, n\} $
  \begin{itemize}
  \item $(a_i,o_j)\in E $
  \item $(s,a_i)\in E$
  \item $(o_j,t) \in E$
  \end{itemize}
\end{itemize}  

Il reste à décrire les capacités sur chaque arc. 
\begin{align*}
\forall i,j \in \{1, \dots, n\} c(a_i,o_j)&=1 \mbox{ si } c(a_i,o_j)-\lambda>0\\
\forall i,j \in \{1, \dots, n\} c(a_i,o_j)&=1 \mbox{ sinon}\\
\forall i \in \{1, \dots, n\},\ c(s,a_i)&=1\\
\forall j \in \{1, \dots, n\},\ c(o_j,t)&=1\\
\end{align*}

\subsubsection{Correction du graphe}

En construisant le graphe de cette façon, on remarque qu'un flot maximal ne correspond pas forcément à un problème d'affectation. En effet, rien ne garanti que le flot sera composé qu'avec des capacités entières. Cependant, on a la propriété suivante :

\begin{prop}
Si le graphe $G=(V,E)$ construit précédemment à un flot maximal, alors il existe un flot maximal à coefficient entier, i.e. le coefficient de chaque arc est soit $0$ soit $1$. 
\end{prop}

\begin{proof}
Par maximalité, tous les $c(o_j,t)$ et les $c(s,a_i)$ sont à $1$. Le seul cas intéressant se situe quand un objet est distribué entre plusieurs agents. Soit $\mathcal{F}$ un float maximum. Soit $o$ un tel objet et $a_k$ les agents assignés à $o$. Alors Par maximalité du flot on a $\sum_{\substack{k\in K}} c_{\mathcal{F}}(a_k,o)=1$. On choisit alors la construction consiste à choisir un agent $k$ parmi les $a_k$ et lui assigner cet objet en mettant sa capacité dans e nouveau flot à $1$. Par construction du graphe, on peut répartir les capacités restant des arc $(a_{-k}, o)$ sur les autres objets assignés à l'agent $k$. On peut itérer ce processus jusqu'à ce que toutes les arrêtes soient des coefficients entiers.
\end{proof}

Cette construction ne garanti en rien la maximalité du flot vis à vis des utilités des agents. C'est justement le but de l'algorithme suivant de le faire.

\subsubsection{Descrption de l'algorithme : }


\subsection{Question 5}
On formule le programme linéaire suivant :

\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{x_{i,j}}{\mathbb{B}}{1 \leq i,j \leq n}{Vaut $1$ si l'agent $a_i$ reçoit le bien $b_j$}
\variable{z_{min}}{\mathbb{R}^+}{}{Satisfaction minimum d'un agent parmi tous les agents}
\end{variables}

\begin{fonctionobj}
\fobj{\boldmax z_{min}} {}
\end{fonctionobj}

\begin{contraintes}
    \constraint{\sum_{i=1}^n x_{i,j} =1}{ 1\leq j\leq n}{$1$ agent par bien}
    \constraint{\sum_{j=1}^n x_{i,j} =1}{ 1\leq i\leq n}{$1$ bien par agent}
    \constraint{ \sum_{\substack{1\leq i,j \leq n}} u_{i,j}x_{i,j} -z_{min} \geq 0}{1\leq i \leq n}{$z_{min}$ doit être plus petit que la satisfaction de l'agent $i$}
\end{contraintes}

\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{P}_1$}

\subsection{Question 6}

Vous trouverez les résultats dans le tableau \ref{question6}
\begin{table}
\begin{center}
\csvautotabular{csv/question_6/time_100.csv}
\caption{Comparaison des temps moyens (en seconde) entre les deux implémentations lorsque $M=100$}
\label{question6}
\end{center}
\end{table}

On remarque dans ces résultats que l'algorithme utilisant les graphs en calculant le flot maximum est plus lent. Pour autant, on ne peut pas dire que cette dernière méthode est plus lente. En effet, bien que le modèle du programme linéaire de $\mathcal{P}_1$, \textit{gurobi} est implémenté en C/C++ qui est un langage beaucoup plus rapide que le Python. Afin d'avoir des mesures un peu plus comparable, il faudrait implémenter l'algorithme de graphe en C/C++ efficacement ! 

Cependant, les résultats peuvent laisser penser que l'approche par programmation linéaire est plus rapide en pratique. Ceci n'est pas très étonnant. Gurobi est un outil payant et maintenu par quelques dizaines de personnes. L'algorithme du simplexe profite aussi de nombreuses améliorations. A l'inverse, la librairie pygraph est en python, et elle n'est pas certainement pas optimisée.
\subsection{Question 7}

D'après le tableau \ref{question7}, on peut observer que maximiser la satisfaction de l'agent le moins satisfait entraîne une répartition plus équitable des produits que lorsque l'on maximise la moyenne. A contrario, la moyenne des satisfactions par le programme $\mathcal{P}_1$ à tendance à être plus faible que la moyenne des satisfactions du programme $\mathcal{P}_0$.


\begin{table}
\csvautotabular {csv/question_7/res_5.csv}
\caption{comparatif du modèle max et maxmin pour n=5  }
\csvautotabular {csv/question_7/res_10.csv}
\caption{comparatif du modèle max et maxmin pour n=10 }
\label{question7}
\end{table}


\subsection{Question 8}

Nous proposons la modélisation suivante pour $\mathcal{P}_2$ :
\subsubsection{Modélisation de $\mathcal{P}_2$}
\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{x_{i,j}}{\mathbb{B}}{1 \leq i,j \leq n}{Vaut $1$ si l'agent $a_i$ reçoit le bien $b_j$}
\variable{z_{min}}{\mathbb{R}^+}{}{Satisfaction minimum d'un agent parmi tous les agents}
\end{variables}

\begin{fonctionobj}
\fobj{\boldmax z_{min}+ \sum_{\substack{1\leq i,j \leq n}} \varepsilon u_{i,j}x_{i,j} } {}
\end{fonctionobj}

\begin{contraintes}
    \constraint{\sum_{i=1}^n x_{i,j} =1}{ 1\leq j\leq n}{$1$ agent par bien}
    \constraint{\sum_{j=1}^n x_{i,j} =1}{ 1\leq i\leq n}{$1$ bien par agent}
    \constraint{ \sum_{\substack{1\leq i,j \leq n}} u_{i,j}x_{i,j} -z_{min} \geq 0}{1\leq i \leq n}{$z_{min}$ doit être plus petit que la satisfaction de l'agent $i$}
\end{contraintes}

\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{P}_2$}

\subsubsection{Comparaison de $\mathcal{P}_1$ avec $\mathcal{P}_2$}

Afin de comparer les programmes $\mathcal{P}_1$ et $\mathcal{P}_2$, on se propose de modéliser le problème suivant :
\begin{quote}
L'association ASCII est une association de récupération de matériel informatique. Elle vient de réparer deux ordinateurs. Le premier ordinateur est un Macbook pro de 2010 et l'autre ordinateur est un PC sorti en 2009 avec une configuration moyenne et avec Debain d'installé. Deux personnes se sont prononcés pour récupérer ces ordinateurs :
\begin{itemize}
\item Mr Michu souhaite un ordinateur pour faire de la bureautique. Il n'a pas de préférence personnel.
\item Mr Zuckerberg souhaite un ordinateur afin de l'aider dans le développement de sa nouvelle idée pour conquérir le monde. Biensûr, il a une préférence pour l'ordinateur sous Debian.
\end{itemize}

La tâche de l'association ASCII est de distribuer les ordinateurs afin de satisfaire au maximum les besoin de Mr. Michu et de MR. Zuckerberg. L'association a donc définit une valeur qui correspond à l'utilité d'un des ordinateurs pour chacun des clients.

L'association a définit que l'utilité de Mr Michu pour les des deux ordinateurs est $2$ puisque ce dernier n'a pas de préférence.
Par contre, pour Mr Zuckerberg, l'association à définit que l'utilité pour lui d'avoir le Macbook pro serait de $3$ et de $10^6$ s'il avait l'ordinateur sous Debian. 
\end{quote}

On peut évidemment modéliser ce problème comme un problème d'affectation. On obtient donc $4$ variables à savoir :
\begin{itemize}
\item $x_{Michu, Mac}$~;
\item $x_{Michu, PC}$~;
\item $x_{Zuckerberg, Mac}$~;
\item $x_{Zuckerberg, Mac}$~;
\end{itemize}

Leurs coefficients dans la fonction objectif sont donnés directement dans le problème. Par le programme $\mathcal{P}_1$, il y a deux solutions possibles : 
\begin{enumerate}
\item $(x_{Michu, Mac},x_{Michu, PC},x_{Zuckerberg, Mac},x_{Zuckerberg, PC})$=(1,0,0,1)~;
\item $(x_{Michu, Mac},x_{Michu, PC},x_{Zuckerberg, Mac},x_{Zuckerberg, PC})$=(0,1,1,0)~;
\end{enumerate}

En effet, dans la deux cas, la satisfaction associée à Mr Michu est de $2$ et la satisfaction de Mr Zuckerberg est plus  grande.

A l'inverse, par le programme $\mathcal{P}_2$, il y a qu'une solution possible :
\begin{itemize}
\item $(x_{Michu, Mac},x_{Michu, PC},x_{Zuckerberg, Mac},x_{Zuckerberg, PC})$=(1,0,0,1)~;
\end{itemize}

En effet, la satisfaction de Mr Zuckerberg est plus grande dans la solution $1$ que dans la solution $2$. Cela entraîne donc que la fonction objectif est plus grande dans la solution $1$ que dans la solution $2$ car la satisfaction de Mr Michu n'a pas changé.

On vient donc de trouver deux solutions différentes tel qu'avec le programme $\mathcal{P}_1$ la satisfaction de Mr Suckerberg soit strictement plus petit que dans la solution du programme $\mathcal{P}_2$ tandis que celle de Mr Michu n'a pas changé.

Les remarques qu'on peut en tirer c'est que maximiser seulement la satisfaction de l'agent le moins satisfait n'est pas suffisant. En effet, comme on le voit dans l'exemple précédent, il peut y avoir plusieurs solutions et alors on ne sait pas laquelle sera donnée par le simplexe. Afin de pallier ce problème, il faut dire au simplexe qu'il faut tout de même maximiser la satisfaction des agents sans pour autant outrepasser l'objectif premier de maximiser la satisfaction de l'agent le moins satisfait. Pour cela, on rajoute un facteur $\varepsilon$ qui permet de différencier les différentes solutions possibles trouvées par le programme $\mathcal{P}_1$.



\section{Approche égalitariste en regrets}

\subsection{Question 9}

\subsubsection{Modélisation de $\mathcal{P}_3$}
\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{x_{i,j}}{\mathbb{B}}{1 \leq i,j \leq n}{Vaut $1$ si l'agent $a_i$ reçoit le bien $b_j$}
\variable{r_{max}}{\mathbb{R}^+}{}{Satisfaction minimum d'un agent parmi tous les agents}
\end{variables}

\begin{fonctionobj}
\fobj{\boldmax r_{max}} {}
\end{fonctionobj}

\begin{contraintes}
    \constraint{\sum_{i=1}^n x_{i,j} =1}{ 1\leq j\leq n}{$1$ agent par bien}
    \constraint{\sum_{j=1}^n x_{i,j} =1}{ 1\leq i\leq n}{$1$ bien par agent}
    \constraint{ \sum_{\substack{1\leq i,j \leq n}} u_{i,j}x_{i,j} +r_{max} \geq z_i*}{1\leq i \leq n}{$r_{max}$ doit être plus grand que le regret de l'agent $i$}
\end{contraintes}
\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{P}_3$}

\subsection{Question 10}
L'approche égalitariste et l'approche par regret sont vraiment proches. En particulier, la construction du graphe sera équivalente. Ce qui va changer sera l'algorithme afin de minimiser le regret.

\subsubsection{Description de l'algorithme :}


\subsection{Question 11}
Vous trouverez les résultats dans le tableau \ref{question11}
\begin{table}
\begin{center}
\csvautotabular{csv/question_11/time_100.csv}
\caption{Comparaison des temps moyens (en seconde) entre les deux implémentations lorsque $M=100$}
\label{question11}
\end{center}
\end{table}

Comme à la question $6$, on s'aperçoit que l'implémentation par graphe semble plus lente que celle utilisant l'algorithme du simplexe. Ici aussi, les remarques sur la performance des langages s'appliquent.
\section{Extension à l'affectation multiple}

\subsection{Question 12}

L'affectation multiple est une généralisation du problème d'affectation simple. L'agent peut recevoir plusieurs objets et chaque objet est en différent exemplaires.

Afin de considérer les changements, on va découper cette question deux deux parties. Une première partie qui regardera seulement le côté programmation linéaire, et une second partie où l'on regardera l'approche par les graphes.

\subsubsection{Approche par programmation linéaire}

D'abord on va considérer les modifications à faire par rapport au programme $\mathcal{P}_0$. Ces modifications se réperctueront sur les deux autres approches. Ensuite on regardera les modifications à faire pour l'approche égalitariste et l'approche par regret.

\paragraph{Maximiser la moyenne des satisfactions : }

Dans le programme $\mathcal{P}_0$, nous avions deux types de contraintes. Le premier type de contraintes obligeait les agents à ne choisir qu'un objet. Cela correspond au cas où $\forall i \in \{1,..,n\} \alpha_i =1$. Ce $1$ se répercutait dans le membre de droite. Donc cela ce généralise très bien en remplaçant le membre de droite par $\alpha_i$. On peut faire la même remarque pour les $\beta_j$ qui correspondent au deuxième types de contraintes. On remarquera qu'on assouplit facilement la contrainte $m=n$. Cela se répercute juste sur le nombre de contraintes du problème. De plus, on remarquera que cette généralisation n'a aucune incidence sur la fonction objectif. La dernière chose à remarquer, c'est qu'en gardant des variables booléennes, on oblige à ce que chaque agent $i$ choisissent un objet une seule fois. Or, si cet objet éxiste en plusieurs exemplaires, l'agent $i$ voudra peut-être le prendre plusieurs fois. Il faut alors relâcher le domaine des variables. On obtient donc le programme linéaire $\mathcal{P'}_0$ suivant :

\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{x_{i,j}}{\mathbb{N}}{1 \leq i,j \leq n}{Vaut $n$ si l'agent $a_i$ reçoit $n$ fois le bien $b_j$}
\end{variables}

\begin{fonctionobj}

\fobj{\boldmax \ \frac{1}{n}\ \sum_{\substack{1\leq i,j \leq n,m}} u_{i,j}x_{i,j}}
{avec $u_{i,j}$ les coefficients d'utilités du bien $i$ pour l'agent $j$}
\end{fonctionobj}

\begin{contraintes}
   \constraint{\sum_{i=1}^n x_{i,j} \leq \beta_j}{ 1\leq j\leq m}{$\beta_j$ agent par bien}
   \constraint{\sum_{j=1}^m x_{i,j} \leq \alpha_i}{ 1\leq i\leq n}{$\alpha_i$ bien par agent}
\end{contraintes}

\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{P'}_0$}

\paragraph{Approche égalitariste : } Dans l'approche égalitariste, les modifications faites précédement ne changent pas. De plus, la notion de satisfaction ne change pas. Par conséquent le programme $\mathcal{P}_1$ se généralise simplement en appliquant les modifications précédentes.

\paragraph{Approche par regret : } cette approche se généralise très bien à une petite différence prêt. $r_i(x)$ est définit en utilisant $z_i^*$. Seulement la définition de $z_i^*$ s'applique seulement si l'agent choisit un seul objet. Il faut donc donner une nouvelle définition de $z_i^*$. Moralement $z_i^*$ est un majorant de la satisfaction maximale que peut espérer l'agent $i$. Cependant si l'agent $i$ peut recevoir $\alpha_i$ objets, alors $\alpha_i \times \boldmax \{u_{i,j} \mid j\in \{1,..., m\}$ est bien un majorant mais pas une borne supérieure. On peut donc affiner la définition de $z_i^*$ pour obtenir une borne supérieure. 

Soit $\mathcal{U}_i$ le multiensemble des utilités de l'agent $i$ : 
$$\mathcal{U}_i=(U_i,m)$$ où 
\begin{itemize}
\item $U_i=\{u_{i,j} \mid j \in \{1,\dots,m\}$~;
\item $m(u_{i,j})=\beta_j$~;
\end{itemize}

Alors on peut définit $z_i^*$ comme :
$$z_i^*=\sum_{\substack{i \in z_i^{\alpha_i}}} i$$ 
où $z_i^{n}$ est le multiensemble définit inductivement pour tout $n\in \mathbb{N}$ : 
\begin{align*}
z_i^0 &= \emptyset \\
z_i^{n+1} &= \boldmax \{u_{i,j} \mid u_{i,j} \in \mathcal{U}_i \setminus z_i^{n} \} \cup z_i^{n} 
\end{align*} 

La définition de $z_i^*$ donne directement un algorithme pour le calculer. Par conséquent, il suffit de reprendre la modélisation $\mathcal{P}_3$ en utilisant la nouvelle définition de $z_i^*$.

\subsubsection{Approche par graphe}

On s'intéresse ici aux algorithmes de graphe pour le problème d'affectation multiple lorsque l'on considère les deux approches précédentes :
\begin{itemize}
\item l'approche égalitariste~;
\item l'approche par regret~;
\end{itemize}

\paragraph{Approche égalitariste :}

Le problème de l'affectation multiple ne change pas la topologie du graphe. Seul les capacités doivent changer. Dans le cas de l'aproche égalitariste les nouvelles capacités seront : 
TO DO !
\begin{align*}
\forall i,j \in \{1, \dots, n\} c(a_i,o_j)&=1 \mbox{ si } c(a_i,o_j)-\lambda>0\\
\forall i,j \in \{1, \dots, n\} c(a_i,o_j)&=1 \mbox{ sinon}\\
\forall i \in \{1, \dots, n\},\ c(s,a_i)&=\alpha_i\\
\forall j \in \{1, \dots, n\},\ c(o_j,t)&=\beta_j\\
\end{align*}

\paragraph{Approche par regret : }

TO DO !
\begin{align*}
\forall i,j \in \{1, \dots, n\} c(a_i,o_j)&=1 \mbox{ si } c(a_i,o_j)-\lambda>0\\
\forall i,j \in \{1, \dots, n\} c(a_i,o_j)&=1 \mbox{ sinon}\\
\forall i \in \{1, \dots, n\},\ c(s,a_i)&=\alpha_i\\
\forall j \in \{1, \dots, n\},\ c(o_j,t)&=\beta_j\\
\end{align*}

\section{Allocation équitable avec l'opérateur OWA}
\subsection{Question 13}

Nous avons légèrement modifier $\mathcal{P}_{\mathcal{L}_k}$ afin de transformer la contrainte d'égalité en deux contraintes. On obtient alors le programme linéaire $\mathcal{D}_{\mathcal{L}_k}$ suivant :
\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{d_{seuil}^+}{\mathbb{R}^+}{}{}
\variable{d_{seuil}^-}{\mathbb{R}^+}{}{}
\variable{d_{i}}{\mathbb{R}^+}{1\leq i \leq n}{}
\end{variables}

\begin{fonctionobj}
\fobj{\boldmax \ k(d_{seuil}^+ -d_{seuil}^-) -\sum_{\substack{1\leq i \leq n}} d_i} {}
\end{fonctionobj}

\begin{contraintes}
    \constraint{d_{seuil}^+-d_{seuil}^- -d_i \leq z_i(x)}{ 1\leq i\leq n}{}
\end{contraintes}
\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{D}_{\mathcal{L}_k}$}

Ce qui est intéressant dans le dual c'est de remarquer que les $z_i(x)$ passent dans les contraintes. Là où dans le primal, $z_i(x)$ devaient obligatoirement être des constantes car c'était le coefficient associé à la variable $y_{i_k}$, maintenant, on peut envisager $z_i(x)$ comme étant une variable.

On peut donc en déduire le programme linéaire suivant $\mathcal{L}_k(x)$ afin de calculer pour $k$ fixé $\mathcal{L}_k(x)$ :
\begin{mdframed}[style=MyFrame]


\begin{variables}
\variable{d_{seuil}^+}{\mathbb{R}^+}{}{}
\variable{d_{seuil}^-}{\mathbb{R}^+}{}{}
\variable{d_{i}}{\mathbb{R}^+}{1\leq i \leq n}{}
\variable{x_{i,j}}{\mathbb{B}}{1 \leq i,j \leq n}{Vaut $1$ si l'agent $a_i$ reçoit le bien $b_j$}
\end{variables}

\begin{fonctionobj}
\fobj{\boldmax \ k(d_{seuil}^+ -d_{seuil}^-) -\sum_{\substack{1\leq i \leq n}} d_i} {}
\end{fonctionobj}

\begin{contraintes}
    \constraint{\sum_{\substack{1\leq j \leq n}} u_{i,j}x_{i,j} +d_i \geq d_{seuil}^+-d_{seuil}^-}{ 1\leq i\leq n}{}
\end{contraintes}
\end{mdframed}
\captionof{lstlisting}{Programme linéaire $\mathcal{L}_k$}

L'intérêt de résoudre ce problème dans le contexte du partage équitable est d'assurer une répartition des satisfaction qui soit \textit{équitable}. C'est à dire qu'il n'y ait pas seulement $n-k$ agents qui soit extrêmement content même si cela peut-être profitable pour l'intérêt de tous, mais que les $k$ agents soient aussi satisfaient. On pourrait aussi voir ça d'une certaine façon pour contrer le \textit{principe de Pareto}.

\subsection{question 14}

Afin de maximiser l'opérateur $\mathit{OWA}$ nous considérons les $L_k(x)$ comme des \textit{méta-variables} que seul le programme $\mathcal{L}_k$ peut comprendre. Une occurence d'une variable $L_k(x)$ se traduit donc en quelque sort par une occurence du programme $\mathcal{L}_k$. Cela nous amène donc à considérer le programme linéaire $\mathcal{O}\mathcal{W}\mathcal{A}$ suivant :
\section{Annexe}

\paragraph{Description du graphe : } On décrit dans ce paragraphe la construction du graphe lié au problème. 

Soit $n$ le nombre d'agents ainsi que le nombre de bien à répartir. Soit $u_{i,j}$ l'utilité du bien $j$ pour l'agent $i$. 
On fait l'hypothèse que les coefficient de la mtrice $u_{i,j}$ soient distincts\footnote{L'hypothèse n'est pas très forte car il suffit sinon de tirer au hasard un $\varepsilon>0$ pour différencier les coefficients égaux}. 
On construit le graphe orienté suivant :
$G=(V,E)$ où 
\begin{itemize}
\item $V=\{s,u_1,_u2,\dots, u_n, b_1,b_2,\dots, b_n,p\}$
\item $\forall i,j \in \{1,\dots, n\} $
  \begin{itemize}
  \item $(u_i,b_j)\in E $
  \item $(s,u_i)\in E$
  \item $(b_j,p) \in E$
  \end{itemize}
\end{itemize}  

Il reste à décrire les capacités sur chaque arc. 
\begin{itemize}
\item  $\forall i,j \in \{1, \dots, n\} c(u_i,b_j)=u_{i,j}-\lambda$
\item $\forall i \in \{1, \dots, n\},\ c(s,u_i)=\min_{\substack{j}} \{c(u_i,b_j) \mid c(u_i,b_j)\geq 0\}$
\item $\forall j \in \{1, \dots, n\},\ c(b_j,p)=\min_{\substack{i}} \{c(u_i,b_j) \mid c(u_i,b_j)\geq 0\}$
\end{itemize}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
